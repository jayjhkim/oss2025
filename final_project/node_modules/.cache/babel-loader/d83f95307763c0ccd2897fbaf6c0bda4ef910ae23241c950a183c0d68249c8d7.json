{"ast":null,"code":"import adjust_lon from '../common/adjust_lon';\nimport { D2R, R2D, HALF_PI, EPSLN } from '../constants/values';\nimport Proj from '../Proj';\nimport { names as longLatNames } from './longlat';\n\n/**\n    Original projection implementation:\n        https://github.com/OSGeo/PROJ/blob/46c47e9adf6376ae06afabe5d24a0016a05ced82/src/projections/ob_tran.cpp\n\n    Documentation:\n        https://proj.org/operations/projections/ob_tran.html\n\n    References/Formulas:\n        https://pubs.usgs.gov/pp/1395/report.pdf\n\n    Examples:\n        +proj=ob_tran +o_proj=moll +o_lat_p=45 +o_lon_p=-90\n        +proj=ob_tran +o_proj=moll +o_lat_p=45 +o_lon_p=-90 +lon_0=60\n        +proj=ob_tran +o_proj=moll +o_lat_p=45 +o_lon_p=-90 +lon_0=-90\n*/\n\nconst projectionType = {\n  OBLIQUE: {\n    forward: forwardOblique,\n    inverse: inverseOblique\n  },\n  TRANSVERSE: {\n    forward: forwardTransverse,\n    inverse: inverseTransverse\n  }\n};\n\n/**\n * @typedef {Object} LocalThis\n * @property {number} lamp\n * @property {number} cphip\n * @property {number} sphip\n * @property {Object} projectionType\n * @property {string | undefined} o_proj\n * @property {string | undefined} o_lon_p\n * @property {string | undefined} o_lat_p\n * @property {string | undefined} o_alpha\n * @property {string | undefined} o_lon_c\n * @property {string | undefined} o_lat_c\n * @property {string | undefined} o_lon_1\n * @property {string | undefined} o_lat_1\n * @property {string | undefined} o_lon_2\n * @property {string | undefined} o_lat_2\n * @property {number | undefined} oLongP\n * @property {number | undefined} oLatP\n * @property {number | undefined} oAlpha\n * @property {number | undefined} oLongC\n * @property {number | undefined} oLatC\n * @property {number | undefined} oLong1\n * @property {number | undefined} oLat1\n * @property {number | undefined} oLong2\n * @property {number | undefined} oLat2\n * @property {boolean} isIdentity\n * @property {import('..').Converter} obliqueProjection\n *\n */\n\n/**\n *    Parameters can be from the following sets:\n *       New pole --> o_lat_p, o_lon_p\n *       Rotate about point --> o_alpha, o_lon_c, o_lat_c\n *       New equator points --> lon_1, lat_1, lon_2, lat_2\n *\n *    Per the original source code, the parameter sets are\n *    checked in the order of the object below.\n */\nconst paramSets = {\n  ROTATE: {\n    o_alpha: 'oAlpha',\n    o_lon_c: 'oLongC',\n    o_lat_c: 'oLatC'\n  },\n  NEW_POLE: {\n    o_lat_p: 'oLatP',\n    o_lon_p: 'oLongP'\n  },\n  NEW_EQUATOR: {\n    o_lon_1: 'oLong1',\n    o_lat_1: 'oLat1',\n    o_lon_2: 'oLong2',\n    o_lat_2: 'oLat2'\n  }\n};\n\n/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */\nexport function init() {\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.long0 = this.long0 || 0;\n  this.title = this.title || 'General Oblique Transformation';\n  this.isIdentity = longLatNames.includes(this.o_proj);\n\n  /** Verify required parameters exist */\n  if (!this.o_proj) {\n    throw new Error('Missing parameter: o_proj');\n  }\n  if (this.o_proj === `ob_tran`) {\n    throw new Error('Invalid value for o_proj: ' + this.o_proj);\n  }\n  const newProjStr = this.projStr.replace('+proj=ob_tran', '').replace('+o_proj=', '+proj=').trim();\n\n  /** @type {import('../defs.js').ProjectionDefinition} */\n  const oProj = Proj(newProjStr);\n  if (!oProj) {\n    throw new Error('Invalid parameter: o_proj. Unknown projection ' + this.o_proj);\n  }\n  oProj.long0 = 0; // we handle long0 before/after forward/inverse\n  this.obliqueProjection = oProj;\n  let matchedSet;\n  const paramSetsKeys = Object.keys(paramSets);\n\n  /**\n   * parse strings, convert to radians, throw on NaN\n   * @param {string} name\n   * @returns {number | undefined}\n   */\n  const parseParam = name => {\n    if (typeof this[name] === `undefined`) {\n      return undefined;\n    }\n    const val = parseFloat(this[name]) * D2R;\n    if (isNaN(val)) {\n      throw new Error('Invalid value for ' + name + ': ' + this[name]);\n    }\n    return val;\n  };\n  for (let i = 0; i < paramSetsKeys.length; i++) {\n    const setKey = paramSetsKeys[i];\n    const set = paramSets[setKey];\n    const params = Object.entries(set);\n    const setHasParams = params.some(([p]) => typeof this[p] !== 'undefined');\n    if (!setHasParams) {\n      continue;\n    }\n    matchedSet = set;\n    for (let ii = 0; ii < params.length; ii++) {\n      const [inputParam, param] = params[ii];\n      const val = parseParam(inputParam);\n      if (typeof val === 'undefined') {\n        throw new Error('Missing parameter: ' + inputParam + '.');\n      }\n      this[param] = val;\n    }\n    break;\n  }\n  if (!matchedSet) {\n    throw new Error('No valid parameters provided for ob_tran projection.');\n  }\n  const {\n    lamp,\n    phip\n  } = createRotation(this, matchedSet);\n  this.lamp = lamp;\n  if (Math.abs(phip) > EPSLN) {\n    this.cphip = Math.cos(phip);\n    this.sphip = Math.sin(phip);\n    this.projectionType = projectionType.OBLIQUE;\n  } else {\n    this.projectionType = projectionType.TRANSVERSE;\n  }\n}\n\n// ob_tran forward equations--mapping (lat,long) to (x,y)\n// transverse (90 degrees from normal orientation) - forwardTransverse\n// or oblique (arbitrary angle) used based on parameters - forwardOblique\n// -----------------------------------------------------------------\n/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */\nexport function forward(p) {\n  return this.projectionType.forward(this, p);\n}\n\n// inverse equations--mapping (x,y) to (lat,long)\n// transverse: inverseTransverse\n// oblique: inverseOblique\n// -----------------------------------------------------------------\n/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */\nexport function inverse(p) {\n  return this.projectionType.inverse(this, p);\n}\n\n/**\n * @param {import('../defs.js').ProjectionDefinition & LocalThis} params - Initialized projection definition\n * @param {Object} how - Transformation method\n * @returns {{phip: number, lamp: number}}\n */\nfunction createRotation(params, how) {\n  let phip, lamp;\n  if (how === paramSets.ROTATE) {\n    let lamc = params.oLongC;\n    let phic = params.oLatC;\n    let alpha = params.oAlpha;\n    if (Math.abs(Math.abs(phic) - HALF_PI) <= EPSLN) {\n      throw new Error('Invalid value for o_lat_c: ' + params.o_lat_c + ' should be < 90°');\n    }\n    lamp = lamc + Math.atan2(-1 * Math.cos(alpha), -1 * Math.sin(alpha) * Math.sin(phic));\n    phip = Math.asin(Math.cos(phic) * Math.sin(alpha));\n  } else if (how === paramSets.NEW_POLE) {\n    lamp = params.oLongP;\n    phip = params.oLatP;\n  } else {\n    let lam1 = params.oLong1;\n    let phi1 = params.oLat1;\n    let lam2 = params.oLong2;\n    let phi2 = params.oLat2;\n    let con = Math.abs(phi1);\n    if (Math.abs(phi1) > HALF_PI - EPSLN) {\n      throw new Error('Invalid value for o_lat_1: ' + params.o_lat_1 + ' should be < 90°');\n    }\n    if (Math.abs(phi2) > HALF_PI - EPSLN) {\n      throw new Error('Invalid value for o_lat_2: ' + params.o_lat_2 + ' should be < 90°');\n    }\n    if (Math.abs(phi1 - phi2) < EPSLN) {\n      throw new Error('Invalid value for o_lat_1 and o_lat_2: o_lat_1 should be different from o_lat_2');\n    }\n    if (con < EPSLN) {\n      throw new Error('Invalid value for o_lat_1: o_lat_1 should be different from zero');\n    }\n    lamp = Math.atan2(Math.cos(phi1) * Math.sin(phi2) * Math.cos(lam1) - Math.sin(phi1) * Math.cos(phi2) * Math.cos(lam2), Math.sin(phi1) * Math.cos(phi2) * Math.sin(lam2) - Math.cos(phi1) * Math.sin(phi2) * Math.sin(lam1));\n    phip = Math.atan(-1 * Math.cos(lamp - lam1) / Math.tan(phi1));\n  }\n  return {\n    lamp,\n    phip\n  };\n}\n\n/**\n * Forward (lng, lat) to (x, y) for oblique case\n * @param {import('../defs.js').ProjectionDefinition & LocalThis} self\n * @param {{x: number, y: number}} lp - lambda, phi\n */\nfunction forwardOblique(self, lp) {\n  let {\n    x: lam,\n    y: phi\n  } = lp;\n  lam += self.long0;\n  const coslam = Math.cos(lam);\n  const sinphi = Math.sin(phi);\n  const cosphi = Math.cos(phi);\n  lp.x = adjust_lon(Math.atan2(cosphi * Math.sin(lam), self.sphip * cosphi * coslam + self.cphip * sinphi) + self.lamp);\n  lp.y = Math.asin(self.sphip * sinphi - self.cphip * cosphi * coslam);\n  const result = self.obliqueProjection.forward(lp);\n  if (self.isIdentity) {\n    result.x *= R2D;\n    result.y *= R2D;\n  }\n  return result;\n}\n\n/**\n * Forward (lng, lat) to (x, y) for transverse case\n * @param {import('../defs.js').ProjectionDefinition & LocalThis} self\n * @param {{x: number, y: number}} lp - lambda, phi\n */\nfunction forwardTransverse(self, lp) {\n  let {\n    x: lam,\n    y: phi\n  } = lp;\n  lam += self.long0;\n  const cosphi = Math.cos(phi);\n  const coslam = Math.cos(lam);\n  lp.x = adjust_lon(Math.atan2(cosphi * Math.sin(lam), Math.sin(phi)) + self.lamp);\n  lp.y = Math.asin(-1 * cosphi * coslam);\n  const result = self.obliqueProjection.forward(lp);\n  if (self.isIdentity) {\n    result.x *= R2D;\n    result.y *= R2D;\n  }\n  return result;\n}\n\n/**\n * Inverse (x, y) to (lng, lat) for oblique case\n * @param {import('../defs.js').ProjectionDefinition & LocalThis} self\n * @param {{x: number, y: number}} lp - lambda, phi\n */\nfunction inverseOblique(self, lp) {\n  if (self.isIdentity) {\n    lp.x *= D2R;\n    lp.y *= D2R;\n  }\n  const innerLp = self.obliqueProjection.inverse(lp);\n  let {\n    x: lam,\n    y: phi\n  } = innerLp;\n  if (lam < Number.MAX_VALUE) {\n    lam -= self.lamp;\n    const coslam = Math.cos(lam);\n    const sinphi = Math.sin(phi);\n    const cosphi = Math.cos(phi);\n    lp.x = Math.atan2(cosphi * Math.sin(lam), self.sphip * cosphi * coslam - self.cphip * sinphi);\n    lp.y = Math.asin(self.sphip * sinphi + self.cphip * cosphi * coslam);\n  }\n  lp.x = adjust_lon(lp.x + self.long0);\n  return lp;\n}\n\n/**\n * Inverse (x, y) to (lng, lat) for transverse case\n * @param {import('../defs.js').ProjectionDefinition & LocalThis} self\n * @param {{x: number, y: number}} lp - lambda, phi\n */\nfunction inverseTransverse(self, lp) {\n  if (self.isIdentity) {\n    lp.x *= D2R;\n    lp.y *= D2R;\n  }\n  const innerLp = self.obliqueProjection.inverse(lp);\n  let {\n    x: lam,\n    y: phi\n  } = innerLp;\n  if (lam < Number.MAX_VALUE) {\n    const cosphi = Math.cos(phi);\n    lam -= self.lamp;\n    lp.x = Math.atan2(cosphi * Math.sin(lam), -1 * Math.sin(phi));\n    lp.y = Math.asin(cosphi * Math.cos(lam));\n  }\n  lp.x = adjust_lon(lp.x + self.long0);\n  return lp;\n}\nexport var names = ['General Oblique Transformation', 'General_Oblique_Transformation', 'ob_tran'];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};","map":{"version":3,"names":["adjust_lon","D2R","R2D","HALF_PI","EPSLN","Proj","names","longLatNames","projectionType","OBLIQUE","forward","forwardOblique","inverse","inverseOblique","TRANSVERSE","forwardTransverse","inverseTransverse","paramSets","ROTATE","o_alpha","o_lon_c","o_lat_c","NEW_POLE","o_lat_p","o_lon_p","NEW_EQUATOR","o_lon_1","o_lat_1","o_lon_2","o_lat_2","init","x0","y0","long0","title","isIdentity","includes","o_proj","Error","newProjStr","projStr","replace","trim","oProj","obliqueProjection","matchedSet","paramSetsKeys","Object","keys","parseParam","name","undefined","val","parseFloat","isNaN","i","length","setKey","set","params","entries","setHasParams","some","p","ii","inputParam","param","lamp","phip","createRotation","Math","abs","cphip","cos","sphip","sin","how","lamc","oLongC","phic","oLatC","alpha","oAlpha","atan2","asin","oLongP","oLatP","lam1","oLong1","phi1","oLat1","lam2","oLong2","phi2","oLat2","con","atan","tan","self","lp","x","lam","y","phi","coslam","sinphi","cosphi","result","innerLp","Number","MAX_VALUE"],"sources":["/Users/jihongkim/Desktop/OSS_Final/node_modules/proj4/lib/projections/ob_tran.js"],"sourcesContent":["import adjust_lon from '../common/adjust_lon';\nimport { D2R, R2D, HALF_PI, EPSLN } from '../constants/values';\nimport Proj from '../Proj';\nimport { names as longLatNames } from './longlat';\n\n/**\n    Original projection implementation:\n        https://github.com/OSGeo/PROJ/blob/46c47e9adf6376ae06afabe5d24a0016a05ced82/src/projections/ob_tran.cpp\n\n    Documentation:\n        https://proj.org/operations/projections/ob_tran.html\n\n    References/Formulas:\n        https://pubs.usgs.gov/pp/1395/report.pdf\n\n    Examples:\n        +proj=ob_tran +o_proj=moll +o_lat_p=45 +o_lon_p=-90\n        +proj=ob_tran +o_proj=moll +o_lat_p=45 +o_lon_p=-90 +lon_0=60\n        +proj=ob_tran +o_proj=moll +o_lat_p=45 +o_lon_p=-90 +lon_0=-90\n*/\n\nconst projectionType = {\n  OBLIQUE: {\n    forward: forwardOblique,\n    inverse: inverseOblique\n  },\n  TRANSVERSE: {\n    forward: forwardTransverse,\n    inverse: inverseTransverse\n  }\n};\n\n/**\n * @typedef {Object} LocalThis\n * @property {number} lamp\n * @property {number} cphip\n * @property {number} sphip\n * @property {Object} projectionType\n * @property {string | undefined} o_proj\n * @property {string | undefined} o_lon_p\n * @property {string | undefined} o_lat_p\n * @property {string | undefined} o_alpha\n * @property {string | undefined} o_lon_c\n * @property {string | undefined} o_lat_c\n * @property {string | undefined} o_lon_1\n * @property {string | undefined} o_lat_1\n * @property {string | undefined} o_lon_2\n * @property {string | undefined} o_lat_2\n * @property {number | undefined} oLongP\n * @property {number | undefined} oLatP\n * @property {number | undefined} oAlpha\n * @property {number | undefined} oLongC\n * @property {number | undefined} oLatC\n * @property {number | undefined} oLong1\n * @property {number | undefined} oLat1\n * @property {number | undefined} oLong2\n * @property {number | undefined} oLat2\n * @property {boolean} isIdentity\n * @property {import('..').Converter} obliqueProjection\n *\n */\n\n/**\n *    Parameters can be from the following sets:\n *       New pole --> o_lat_p, o_lon_p\n *       Rotate about point --> o_alpha, o_lon_c, o_lat_c\n *       New equator points --> lon_1, lat_1, lon_2, lat_2\n *\n *    Per the original source code, the parameter sets are\n *    checked in the order of the object below.\n */\nconst paramSets = {\n  ROTATE: {\n    o_alpha: 'oAlpha',\n    o_lon_c: 'oLongC',\n    o_lat_c: 'oLatC'\n  },\n  NEW_POLE: {\n    o_lat_p: 'oLatP',\n    o_lon_p: 'oLongP'\n  },\n  NEW_EQUATOR: {\n    o_lon_1: 'oLong1',\n    o_lat_1: 'oLat1',\n    o_lon_2: 'oLong2',\n    o_lat_2: 'oLat2'\n  }\n};\n\n/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */\nexport function init() {\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.long0 = this.long0 || 0;\n  this.title = this.title || 'General Oblique Transformation';\n  this.isIdentity = longLatNames.includes(this.o_proj);\n\n  /** Verify required parameters exist */\n  if (!this.o_proj) {\n    throw new Error('Missing parameter: o_proj');\n  }\n\n  if (this.o_proj === `ob_tran`) {\n    throw new Error('Invalid value for o_proj: ' + this.o_proj);\n  }\n\n  const newProjStr = this.projStr.replace('+proj=ob_tran', '').replace('+o_proj=', '+proj=').trim();\n\n  /** @type {import('../defs.js').ProjectionDefinition} */\n  const oProj = Proj(newProjStr);\n  if (!oProj) {\n    throw new Error('Invalid parameter: o_proj. Unknown projection ' + this.o_proj);\n  }\n  oProj.long0 = 0; // we handle long0 before/after forward/inverse\n  this.obliqueProjection = oProj;\n\n  let matchedSet;\n  const paramSetsKeys = Object.keys(paramSets);\n\n  /**\n   * parse strings, convert to radians, throw on NaN\n   * @param {string} name\n   * @returns {number | undefined}\n   */\n  const parseParam = (name) => {\n    if (typeof this[name] === `undefined`) {\n      return undefined;\n    }\n    const val = parseFloat(this[name]) * D2R;\n    if (isNaN(val)) {\n      throw new Error('Invalid value for ' + name + ': ' + this[name]);\n    }\n    return val;\n  };\n\n  for (let i = 0; i < paramSetsKeys.length; i++) {\n    const setKey = paramSetsKeys[i];\n    const set = paramSets[setKey];\n    const params = Object.entries(set);\n    const setHasParams = params.some(\n      ([p]) => typeof this[p] !== 'undefined'\n    );\n    if (!setHasParams) {\n      continue;\n    }\n    matchedSet = set;\n    for (let ii = 0; ii < params.length; ii++) {\n      const [inputParam, param] = params[ii];\n      const val = parseParam(inputParam);\n      if (typeof val === 'undefined') {\n        throw new Error('Missing parameter: ' + inputParam + '.');\n      }\n      this[param] = val;\n    }\n    break;\n  }\n\n  if (!matchedSet) {\n    throw new Error('No valid parameters provided for ob_tran projection.');\n  }\n\n  const { lamp, phip } = createRotation(this, matchedSet);\n  this.lamp = lamp;\n\n  if (Math.abs(phip) > EPSLN) {\n    this.cphip = Math.cos(phip);\n    this.sphip = Math.sin(phip);\n    this.projectionType = projectionType.OBLIQUE;\n  } else {\n    this.projectionType = projectionType.TRANSVERSE;\n  }\n}\n\n// ob_tran forward equations--mapping (lat,long) to (x,y)\n// transverse (90 degrees from normal orientation) - forwardTransverse\n// or oblique (arbitrary angle) used based on parameters - forwardOblique\n// -----------------------------------------------------------------\n/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */\nexport function forward(p) {\n  return this.projectionType.forward(this, p);\n}\n\n// inverse equations--mapping (x,y) to (lat,long)\n// transverse: inverseTransverse\n// oblique: inverseOblique\n// -----------------------------------------------------------------\n/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */\nexport function inverse(p) {\n  return this.projectionType.inverse(this, p);\n}\n\n/**\n * @param {import('../defs.js').ProjectionDefinition & LocalThis} params - Initialized projection definition\n * @param {Object} how - Transformation method\n * @returns {{phip: number, lamp: number}}\n */\nfunction createRotation(params, how) {\n  let phip, lamp;\n  if (how === paramSets.ROTATE) {\n    let lamc = params.oLongC;\n    let phic = params.oLatC;\n    let alpha = params.oAlpha;\n    if (Math.abs(Math.abs(phic) - HALF_PI) <= EPSLN) {\n      throw new Error('Invalid value for o_lat_c: ' + params.o_lat_c + ' should be < 90°');\n    }\n    lamp = lamc + Math.atan2(-1 * Math.cos(alpha), -1 * Math.sin(alpha) * Math.sin(phic));\n    phip = Math.asin(Math.cos(phic) * Math.sin(alpha));\n  } else if (how === paramSets.NEW_POLE) {\n    lamp = params.oLongP;\n    phip = params.oLatP;\n  } else {\n    let lam1 = params.oLong1;\n    let phi1 = params.oLat1;\n    let lam2 = params.oLong2;\n    let phi2 = params.oLat2;\n    let con = Math.abs(phi1);\n\n    if (Math.abs(phi1) > HALF_PI - EPSLN) {\n      throw new Error('Invalid value for o_lat_1: ' + params.o_lat_1 + ' should be < 90°');\n    }\n\n    if (Math.abs(phi2) > HALF_PI - EPSLN) {\n      throw new Error('Invalid value for o_lat_2: ' + params.o_lat_2 + ' should be < 90°');\n    }\n\n    if (Math.abs(phi1 - phi2) < EPSLN) {\n      throw new Error('Invalid value for o_lat_1 and o_lat_2: o_lat_1 should be different from o_lat_2');\n    }\n    if (con < EPSLN) {\n      throw new Error('Invalid value for o_lat_1: o_lat_1 should be different from zero');\n    }\n\n    lamp = Math.atan2(\n      (Math.cos(phi1) * Math.sin(phi2) * Math.cos(lam1))\n      - (Math.sin(phi1) * Math.cos(phi2) * Math.cos(lam2)),\n      (Math.sin(phi1) * Math.cos(phi2) * Math.sin(lam2))\n      - (Math.cos(phi1) * Math.sin(phi2) * Math.sin(lam1))\n    );\n\n    phip = Math.atan(-1 * Math.cos(lamp - lam1) / Math.tan(phi1));\n  }\n\n  return { lamp, phip };\n}\n\n/**\n * Forward (lng, lat) to (x, y) for oblique case\n * @param {import('../defs.js').ProjectionDefinition & LocalThis} self\n * @param {{x: number, y: number}} lp - lambda, phi\n */\nfunction forwardOblique(self, lp) {\n  let { x: lam, y: phi } = lp;\n  lam += self.long0;\n  const coslam = Math.cos(lam);\n  const sinphi = Math.sin(phi);\n  const cosphi = Math.cos(phi);\n\n  lp.x = adjust_lon(\n    Math.atan2(\n      cosphi * Math.sin(lam),\n      (self.sphip * cosphi * coslam) + (self.cphip * sinphi)\n    ) + self.lamp\n  );\n  lp.y = Math.asin(\n    (self.sphip * sinphi) - (self.cphip * cosphi * coslam)\n  );\n\n  const result = self.obliqueProjection.forward(lp);\n  if (self.isIdentity) {\n    result.x *= R2D;\n    result.y *= R2D;\n  }\n  return result;\n}\n\n/**\n * Forward (lng, lat) to (x, y) for transverse case\n * @param {import('../defs.js').ProjectionDefinition & LocalThis} self\n * @param {{x: number, y: number}} lp - lambda, phi\n */\nfunction forwardTransverse(self, lp) {\n  let { x: lam, y: phi } = lp;\n  lam += self.long0;\n  const cosphi = Math.cos(phi);\n  const coslam = Math.cos(lam);\n  lp.x = adjust_lon(\n    Math.atan2(\n      cosphi * Math.sin(lam),\n      Math.sin(phi)\n    ) + self.lamp\n  );\n  lp.y = Math.asin(-1 * cosphi * coslam);\n\n  const result = self.obliqueProjection.forward(lp);\n\n  if (self.isIdentity) {\n    result.x *= R2D;\n    result.y *= R2D;\n  }\n  return result;\n}\n\n/**\n * Inverse (x, y) to (lng, lat) for oblique case\n * @param {import('../defs.js').ProjectionDefinition & LocalThis} self\n * @param {{x: number, y: number}} lp - lambda, phi\n */\nfunction inverseOblique(self, lp) {\n  if (self.isIdentity) {\n    lp.x *= D2R;\n    lp.y *= D2R;\n  }\n\n  const innerLp = self.obliqueProjection.inverse(lp);\n  let { x: lam, y: phi } = innerLp;\n\n  if (lam < Number.MAX_VALUE) {\n    lam -= self.lamp;\n    const coslam = Math.cos(lam);\n    const sinphi = Math.sin(phi);\n    const cosphi = Math.cos(phi);\n    lp.x = Math.atan2(\n      cosphi * Math.sin(lam),\n      (self.sphip * cosphi * coslam) - (self.cphip * sinphi)\n    );\n    lp.y = Math.asin(\n      (self.sphip * sinphi) + (self.cphip * cosphi * coslam)\n    );\n  }\n\n  lp.x = adjust_lon(lp.x + self.long0);\n  return lp;\n}\n\n/**\n * Inverse (x, y) to (lng, lat) for transverse case\n * @param {import('../defs.js').ProjectionDefinition & LocalThis} self\n * @param {{x: number, y: number}} lp - lambda, phi\n */\nfunction inverseTransverse(self, lp) {\n  if (self.isIdentity) {\n    lp.x *= D2R;\n    lp.y *= D2R;\n  }\n\n  const innerLp = self.obliqueProjection.inverse(lp);\n  let { x: lam, y: phi } = innerLp;\n\n  if (lam < Number.MAX_VALUE) {\n    const cosphi = Math.cos(phi);\n    lam -= self.lamp;\n    lp.x = Math.atan2(\n      cosphi * Math.sin(lam),\n      -1 * Math.sin(phi)\n    );\n    lp.y = Math.asin(\n      cosphi * Math.cos(lam)\n    );\n  }\n\n  lp.x = adjust_lon(lp.x + self.long0);\n  return lp;\n}\n\nexport var names = ['General Oblique Transformation', 'General_Oblique_Transformation', 'ob_tran'];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,sBAAsB;AAC7C,SAASC,GAAG,EAAEC,GAAG,EAAEC,OAAO,EAAEC,KAAK,QAAQ,qBAAqB;AAC9D,OAAOC,IAAI,MAAM,SAAS;AAC1B,SAASC,KAAK,IAAIC,YAAY,QAAQ,WAAW;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,cAAc,GAAG;EACrBC,OAAO,EAAE;IACPC,OAAO,EAAEC,cAAc;IACvBC,OAAO,EAAEC;EACX,CAAC;EACDC,UAAU,EAAE;IACVJ,OAAO,EAAEK,iBAAiB;IAC1BH,OAAO,EAAEI;EACX;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,SAAS,GAAG;EAChBC,MAAM,EAAE;IACNC,OAAO,EAAE,QAAQ;IACjBC,OAAO,EAAE,QAAQ;IACjBC,OAAO,EAAE;EACX,CAAC;EACDC,QAAQ,EAAE;IACRC,OAAO,EAAE,OAAO;IAChBC,OAAO,EAAE;EACX,CAAC;EACDC,WAAW,EAAE;IACXC,OAAO,EAAE,QAAQ;IACjBC,OAAO,EAAE,OAAO;IAChBC,OAAO,EAAE,QAAQ;IACjBC,OAAO,EAAE;EACX;AACF,CAAC;;AAED;AACA,OAAO,SAASC,IAAIA,CAAA,EAAG;EACrB,IAAI,CAACC,EAAE,GAAG,IAAI,CAACA,EAAE,IAAI,CAAC;EACtB,IAAI,CAACC,EAAE,GAAG,IAAI,CAACA,EAAE,IAAI,CAAC;EACtB,IAAI,CAACC,KAAK,GAAG,IAAI,CAACA,KAAK,IAAI,CAAC;EAC5B,IAAI,CAACC,KAAK,GAAG,IAAI,CAACA,KAAK,IAAI,gCAAgC;EAC3D,IAAI,CAACC,UAAU,GAAG5B,YAAY,CAAC6B,QAAQ,CAAC,IAAI,CAACC,MAAM,CAAC;;EAEpD;EACA,IAAI,CAAC,IAAI,CAACA,MAAM,EAAE;IAChB,MAAM,IAAIC,KAAK,CAAC,2BAA2B,CAAC;EAC9C;EAEA,IAAI,IAAI,CAACD,MAAM,KAAK,SAAS,EAAE;IAC7B,MAAM,IAAIC,KAAK,CAAC,4BAA4B,GAAG,IAAI,CAACD,MAAM,CAAC;EAC7D;EAEA,MAAME,UAAU,GAAG,IAAI,CAACC,OAAO,CAACC,OAAO,CAAC,eAAe,EAAE,EAAE,CAAC,CAACA,OAAO,CAAC,UAAU,EAAE,QAAQ,CAAC,CAACC,IAAI,CAAC,CAAC;;EAEjG;EACA,MAAMC,KAAK,GAAGtC,IAAI,CAACkC,UAAU,CAAC;EAC9B,IAAI,CAACI,KAAK,EAAE;IACV,MAAM,IAAIL,KAAK,CAAC,gDAAgD,GAAG,IAAI,CAACD,MAAM,CAAC;EACjF;EACAM,KAAK,CAACV,KAAK,GAAG,CAAC,CAAC,CAAC;EACjB,IAAI,CAACW,iBAAiB,GAAGD,KAAK;EAE9B,IAAIE,UAAU;EACd,MAAMC,aAAa,GAAGC,MAAM,CAACC,IAAI,CAAC/B,SAAS,CAAC;;EAE5C;AACF;AACA;AACA;AACA;EACE,MAAMgC,UAAU,GAAIC,IAAI,IAAK;IAC3B,IAAI,OAAO,IAAI,CAACA,IAAI,CAAC,KAAK,WAAW,EAAE;MACrC,OAAOC,SAAS;IAClB;IACA,MAAMC,GAAG,GAAGC,UAAU,CAAC,IAAI,CAACH,IAAI,CAAC,CAAC,GAAGjD,GAAG;IACxC,IAAIqD,KAAK,CAACF,GAAG,CAAC,EAAE;MACd,MAAM,IAAId,KAAK,CAAC,oBAAoB,GAAGY,IAAI,GAAG,IAAI,GAAG,IAAI,CAACA,IAAI,CAAC,CAAC;IAClE;IACA,OAAOE,GAAG;EACZ,CAAC;EAED,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,aAAa,CAACU,MAAM,EAAED,CAAC,EAAE,EAAE;IAC7C,MAAME,MAAM,GAAGX,aAAa,CAACS,CAAC,CAAC;IAC/B,MAAMG,GAAG,GAAGzC,SAAS,CAACwC,MAAM,CAAC;IAC7B,MAAME,MAAM,GAAGZ,MAAM,CAACa,OAAO,CAACF,GAAG,CAAC;IAClC,MAAMG,YAAY,GAAGF,MAAM,CAACG,IAAI,CAC9B,CAAC,CAACC,CAAC,CAAC,KAAK,OAAO,IAAI,CAACA,CAAC,CAAC,KAAK,WAC9B,CAAC;IACD,IAAI,CAACF,YAAY,EAAE;MACjB;IACF;IACAhB,UAAU,GAAGa,GAAG;IAChB,KAAK,IAAIM,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGL,MAAM,CAACH,MAAM,EAAEQ,EAAE,EAAE,EAAE;MACzC,MAAM,CAACC,UAAU,EAAEC,KAAK,CAAC,GAAGP,MAAM,CAACK,EAAE,CAAC;MACtC,MAAMZ,GAAG,GAAGH,UAAU,CAACgB,UAAU,CAAC;MAClC,IAAI,OAAOb,GAAG,KAAK,WAAW,EAAE;QAC9B,MAAM,IAAId,KAAK,CAAC,qBAAqB,GAAG2B,UAAU,GAAG,GAAG,CAAC;MAC3D;MACA,IAAI,CAACC,KAAK,CAAC,GAAGd,GAAG;IACnB;IACA;EACF;EAEA,IAAI,CAACP,UAAU,EAAE;IACf,MAAM,IAAIP,KAAK,CAAC,sDAAsD,CAAC;EACzE;EAEA,MAAM;IAAE6B,IAAI;IAAEC;EAAK,CAAC,GAAGC,cAAc,CAAC,IAAI,EAAExB,UAAU,CAAC;EACvD,IAAI,CAACsB,IAAI,GAAGA,IAAI;EAEhB,IAAIG,IAAI,CAACC,GAAG,CAACH,IAAI,CAAC,GAAGhE,KAAK,EAAE;IAC1B,IAAI,CAACoE,KAAK,GAAGF,IAAI,CAACG,GAAG,CAACL,IAAI,CAAC;IAC3B,IAAI,CAACM,KAAK,GAAGJ,IAAI,CAACK,GAAG,CAACP,IAAI,CAAC;IAC3B,IAAI,CAAC5D,cAAc,GAAGA,cAAc,CAACC,OAAO;EAC9C,CAAC,MAAM;IACL,IAAI,CAACD,cAAc,GAAGA,cAAc,CAACM,UAAU;EACjD;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASJ,OAAOA,CAACqD,CAAC,EAAE;EACzB,OAAO,IAAI,CAACvD,cAAc,CAACE,OAAO,CAAC,IAAI,EAAEqD,CAAC,CAAC;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASnD,OAAOA,CAACmD,CAAC,EAAE;EACzB,OAAO,IAAI,CAACvD,cAAc,CAACI,OAAO,CAAC,IAAI,EAAEmD,CAAC,CAAC;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASM,cAAcA,CAACV,MAAM,EAAEiB,GAAG,EAAE;EACnC,IAAIR,IAAI,EAAED,IAAI;EACd,IAAIS,GAAG,KAAK3D,SAAS,CAACC,MAAM,EAAE;IAC5B,IAAI2D,IAAI,GAAGlB,MAAM,CAACmB,MAAM;IACxB,IAAIC,IAAI,GAAGpB,MAAM,CAACqB,KAAK;IACvB,IAAIC,KAAK,GAAGtB,MAAM,CAACuB,MAAM;IACzB,IAAIZ,IAAI,CAACC,GAAG,CAACD,IAAI,CAACC,GAAG,CAACQ,IAAI,CAAC,GAAG5E,OAAO,CAAC,IAAIC,KAAK,EAAE;MAC/C,MAAM,IAAIkC,KAAK,CAAC,6BAA6B,GAAGqB,MAAM,CAACtC,OAAO,GAAG,kBAAkB,CAAC;IACtF;IACA8C,IAAI,GAAGU,IAAI,GAAGP,IAAI,CAACa,KAAK,CAAC,CAAC,CAAC,GAAGb,IAAI,CAACG,GAAG,CAACQ,KAAK,CAAC,EAAE,CAAC,CAAC,GAAGX,IAAI,CAACK,GAAG,CAACM,KAAK,CAAC,GAAGX,IAAI,CAACK,GAAG,CAACI,IAAI,CAAC,CAAC;IACrFX,IAAI,GAAGE,IAAI,CAACc,IAAI,CAACd,IAAI,CAACG,GAAG,CAACM,IAAI,CAAC,GAAGT,IAAI,CAACK,GAAG,CAACM,KAAK,CAAC,CAAC;EACpD,CAAC,MAAM,IAAIL,GAAG,KAAK3D,SAAS,CAACK,QAAQ,EAAE;IACrC6C,IAAI,GAAGR,MAAM,CAAC0B,MAAM;IACpBjB,IAAI,GAAGT,MAAM,CAAC2B,KAAK;EACrB,CAAC,MAAM;IACL,IAAIC,IAAI,GAAG5B,MAAM,CAAC6B,MAAM;IACxB,IAAIC,IAAI,GAAG9B,MAAM,CAAC+B,KAAK;IACvB,IAAIC,IAAI,GAAGhC,MAAM,CAACiC,MAAM;IACxB,IAAIC,IAAI,GAAGlC,MAAM,CAACmC,KAAK;IACvB,IAAIC,GAAG,GAAGzB,IAAI,CAACC,GAAG,CAACkB,IAAI,CAAC;IAExB,IAAInB,IAAI,CAACC,GAAG,CAACkB,IAAI,CAAC,GAAGtF,OAAO,GAAGC,KAAK,EAAE;MACpC,MAAM,IAAIkC,KAAK,CAAC,6BAA6B,GAAGqB,MAAM,CAAChC,OAAO,GAAG,kBAAkB,CAAC;IACtF;IAEA,IAAI2C,IAAI,CAACC,GAAG,CAACsB,IAAI,CAAC,GAAG1F,OAAO,GAAGC,KAAK,EAAE;MACpC,MAAM,IAAIkC,KAAK,CAAC,6BAA6B,GAAGqB,MAAM,CAAC9B,OAAO,GAAG,kBAAkB,CAAC;IACtF;IAEA,IAAIyC,IAAI,CAACC,GAAG,CAACkB,IAAI,GAAGI,IAAI,CAAC,GAAGzF,KAAK,EAAE;MACjC,MAAM,IAAIkC,KAAK,CAAC,iFAAiF,CAAC;IACpG;IACA,IAAIyD,GAAG,GAAG3F,KAAK,EAAE;MACf,MAAM,IAAIkC,KAAK,CAAC,kEAAkE,CAAC;IACrF;IAEA6B,IAAI,GAAGG,IAAI,CAACa,KAAK,CACdb,IAAI,CAACG,GAAG,CAACgB,IAAI,CAAC,GAAGnB,IAAI,CAACK,GAAG,CAACkB,IAAI,CAAC,GAAGvB,IAAI,CAACG,GAAG,CAACc,IAAI,CAAC,GAC9CjB,IAAI,CAACK,GAAG,CAACc,IAAI,CAAC,GAAGnB,IAAI,CAACG,GAAG,CAACoB,IAAI,CAAC,GAAGvB,IAAI,CAACG,GAAG,CAACkB,IAAI,CAAE,EACnDrB,IAAI,CAACK,GAAG,CAACc,IAAI,CAAC,GAAGnB,IAAI,CAACG,GAAG,CAACoB,IAAI,CAAC,GAAGvB,IAAI,CAACK,GAAG,CAACgB,IAAI,CAAC,GAC9CrB,IAAI,CAACG,GAAG,CAACgB,IAAI,CAAC,GAAGnB,IAAI,CAACK,GAAG,CAACkB,IAAI,CAAC,GAAGvB,IAAI,CAACK,GAAG,CAACY,IAAI,CACpD,CAAC;IAEDnB,IAAI,GAAGE,IAAI,CAAC0B,IAAI,CAAC,CAAC,CAAC,GAAG1B,IAAI,CAACG,GAAG,CAACN,IAAI,GAAGoB,IAAI,CAAC,GAAGjB,IAAI,CAAC2B,GAAG,CAACR,IAAI,CAAC,CAAC;EAC/D;EAEA,OAAO;IAAEtB,IAAI;IAAEC;EAAK,CAAC;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASzD,cAAcA,CAACuF,IAAI,EAAEC,EAAE,EAAE;EAChC,IAAI;IAAEC,CAAC,EAAEC,GAAG;IAAEC,CAAC,EAAEC;EAAI,CAAC,GAAGJ,EAAE;EAC3BE,GAAG,IAAIH,IAAI,CAACjE,KAAK;EACjB,MAAMuE,MAAM,GAAGlC,IAAI,CAACG,GAAG,CAAC4B,GAAG,CAAC;EAC5B,MAAMI,MAAM,GAAGnC,IAAI,CAACK,GAAG,CAAC4B,GAAG,CAAC;EAC5B,MAAMG,MAAM,GAAGpC,IAAI,CAACG,GAAG,CAAC8B,GAAG,CAAC;EAE5BJ,EAAE,CAACC,CAAC,GAAGpG,UAAU,CACfsE,IAAI,CAACa,KAAK,CACRuB,MAAM,GAAGpC,IAAI,CAACK,GAAG,CAAC0B,GAAG,CAAC,EACrBH,IAAI,CAACxB,KAAK,GAAGgC,MAAM,GAAGF,MAAM,GAAKN,IAAI,CAAC1B,KAAK,GAAGiC,MACjD,CAAC,GAAGP,IAAI,CAAC/B,IACX,CAAC;EACDgC,EAAE,CAACG,CAAC,GAAGhC,IAAI,CAACc,IAAI,CACbc,IAAI,CAACxB,KAAK,GAAG+B,MAAM,GAAKP,IAAI,CAAC1B,KAAK,GAAGkC,MAAM,GAAGF,MACjD,CAAC;EAED,MAAMG,MAAM,GAAGT,IAAI,CAACtD,iBAAiB,CAAClC,OAAO,CAACyF,EAAE,CAAC;EACjD,IAAID,IAAI,CAAC/D,UAAU,EAAE;IACnBwE,MAAM,CAACP,CAAC,IAAIlG,GAAG;IACfyG,MAAM,CAACL,CAAC,IAAIpG,GAAG;EACjB;EACA,OAAOyG,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS5F,iBAAiBA,CAACmF,IAAI,EAAEC,EAAE,EAAE;EACnC,IAAI;IAAEC,CAAC,EAAEC,GAAG;IAAEC,CAAC,EAAEC;EAAI,CAAC,GAAGJ,EAAE;EAC3BE,GAAG,IAAIH,IAAI,CAACjE,KAAK;EACjB,MAAMyE,MAAM,GAAGpC,IAAI,CAACG,GAAG,CAAC8B,GAAG,CAAC;EAC5B,MAAMC,MAAM,GAAGlC,IAAI,CAACG,GAAG,CAAC4B,GAAG,CAAC;EAC5BF,EAAE,CAACC,CAAC,GAAGpG,UAAU,CACfsE,IAAI,CAACa,KAAK,CACRuB,MAAM,GAAGpC,IAAI,CAACK,GAAG,CAAC0B,GAAG,CAAC,EACtB/B,IAAI,CAACK,GAAG,CAAC4B,GAAG,CACd,CAAC,GAAGL,IAAI,CAAC/B,IACX,CAAC;EACDgC,EAAE,CAACG,CAAC,GAAGhC,IAAI,CAACc,IAAI,CAAC,CAAC,CAAC,GAAGsB,MAAM,GAAGF,MAAM,CAAC;EAEtC,MAAMG,MAAM,GAAGT,IAAI,CAACtD,iBAAiB,CAAClC,OAAO,CAACyF,EAAE,CAAC;EAEjD,IAAID,IAAI,CAAC/D,UAAU,EAAE;IACnBwE,MAAM,CAACP,CAAC,IAAIlG,GAAG;IACfyG,MAAM,CAACL,CAAC,IAAIpG,GAAG;EACjB;EACA,OAAOyG,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS9F,cAAcA,CAACqF,IAAI,EAAEC,EAAE,EAAE;EAChC,IAAID,IAAI,CAAC/D,UAAU,EAAE;IACnBgE,EAAE,CAACC,CAAC,IAAInG,GAAG;IACXkG,EAAE,CAACG,CAAC,IAAIrG,GAAG;EACb;EAEA,MAAM2G,OAAO,GAAGV,IAAI,CAACtD,iBAAiB,CAAChC,OAAO,CAACuF,EAAE,CAAC;EAClD,IAAI;IAAEC,CAAC,EAAEC,GAAG;IAAEC,CAAC,EAAEC;EAAI,CAAC,GAAGK,OAAO;EAEhC,IAAIP,GAAG,GAAGQ,MAAM,CAACC,SAAS,EAAE;IAC1BT,GAAG,IAAIH,IAAI,CAAC/B,IAAI;IAChB,MAAMqC,MAAM,GAAGlC,IAAI,CAACG,GAAG,CAAC4B,GAAG,CAAC;IAC5B,MAAMI,MAAM,GAAGnC,IAAI,CAACK,GAAG,CAAC4B,GAAG,CAAC;IAC5B,MAAMG,MAAM,GAAGpC,IAAI,CAACG,GAAG,CAAC8B,GAAG,CAAC;IAC5BJ,EAAE,CAACC,CAAC,GAAG9B,IAAI,CAACa,KAAK,CACfuB,MAAM,GAAGpC,IAAI,CAACK,GAAG,CAAC0B,GAAG,CAAC,EACrBH,IAAI,CAACxB,KAAK,GAAGgC,MAAM,GAAGF,MAAM,GAAKN,IAAI,CAAC1B,KAAK,GAAGiC,MACjD,CAAC;IACDN,EAAE,CAACG,CAAC,GAAGhC,IAAI,CAACc,IAAI,CACbc,IAAI,CAACxB,KAAK,GAAG+B,MAAM,GAAKP,IAAI,CAAC1B,KAAK,GAAGkC,MAAM,GAAGF,MACjD,CAAC;EACH;EAEAL,EAAE,CAACC,CAAC,GAAGpG,UAAU,CAACmG,EAAE,CAACC,CAAC,GAAGF,IAAI,CAACjE,KAAK,CAAC;EACpC,OAAOkE,EAAE;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASnF,iBAAiBA,CAACkF,IAAI,EAAEC,EAAE,EAAE;EACnC,IAAID,IAAI,CAAC/D,UAAU,EAAE;IACnBgE,EAAE,CAACC,CAAC,IAAInG,GAAG;IACXkG,EAAE,CAACG,CAAC,IAAIrG,GAAG;EACb;EAEA,MAAM2G,OAAO,GAAGV,IAAI,CAACtD,iBAAiB,CAAChC,OAAO,CAACuF,EAAE,CAAC;EAClD,IAAI;IAAEC,CAAC,EAAEC,GAAG;IAAEC,CAAC,EAAEC;EAAI,CAAC,GAAGK,OAAO;EAEhC,IAAIP,GAAG,GAAGQ,MAAM,CAACC,SAAS,EAAE;IAC1B,MAAMJ,MAAM,GAAGpC,IAAI,CAACG,GAAG,CAAC8B,GAAG,CAAC;IAC5BF,GAAG,IAAIH,IAAI,CAAC/B,IAAI;IAChBgC,EAAE,CAACC,CAAC,GAAG9B,IAAI,CAACa,KAAK,CACfuB,MAAM,GAAGpC,IAAI,CAACK,GAAG,CAAC0B,GAAG,CAAC,EACtB,CAAC,CAAC,GAAG/B,IAAI,CAACK,GAAG,CAAC4B,GAAG,CACnB,CAAC;IACDJ,EAAE,CAACG,CAAC,GAAGhC,IAAI,CAACc,IAAI,CACdsB,MAAM,GAAGpC,IAAI,CAACG,GAAG,CAAC4B,GAAG,CACvB,CAAC;EACH;EAEAF,EAAE,CAACC,CAAC,GAAGpG,UAAU,CAACmG,EAAE,CAACC,CAAC,GAAGF,IAAI,CAACjE,KAAK,CAAC;EACpC,OAAOkE,EAAE;AACX;AAEA,OAAO,IAAI7F,KAAK,GAAG,CAAC,gCAAgC,EAAE,gCAAgC,EAAE,SAAS,CAAC;AAClG,eAAe;EACbwB,IAAI,EAAEA,IAAI;EACVpB,OAAO,EAAEA,OAAO;EAChBE,OAAO,EAAEA,OAAO;EAChBN,KAAK,EAAEA;AACT,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}